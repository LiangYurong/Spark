





## 判断对象是否需要回收

### 引用记数法（如果两个对象互相引用可以回收吗）

给对象添加一个引用计数器，当有一个地方引用它，计数器值加 1；当引用失效时，计数器值减 1。任何时刻计数器值为 0 表示这个对象可以被回收。

缺点：这种方式实现简单且高效,但是这种方式存在着一种问题,也就是对象的循环依赖.

假设现在有两个对象,他们互相引用值为null,且不存在其他对象对其引用也不存在这两个对象的使用,那么这时这两个对象应该就是垃圾对象,但是由于他们互相引用,所以无法被回收.

### 可达性分析算法

通过一系列称为 "GC Roots" 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。

可达性即这个对象可以到达,对可达性进行分析来判断对象是否存在引用,如果对象可达则不能回收,如果不可达则将对象标记为垃圾对象等待回收,这也是主流虚拟机采用的方式.

那么这个可达性是什么呢,要了解这个概念,我们首先需要了解GC Roots根节点.

可作为 GC Roots 的对象有
	1. 虚拟机栈中的引用的对象
	2. 方法区的静态变量和常量引用的对象
	3. 本地方法栈中 JNI 引用的对象

### 垃圾回收算法 - 标记-清除算法

缺点：会产生很多内存碎片

### 垃圾回收算法 - 标记-复制算法

这个算法将一块内存区域分为完全相等的两块,这两块只能使用一块,另一块做什么用呢,用于垃圾清除后的空间整理。

进行垃圾清除时,他会把当前这一半的所有存活对象依次移入到另一半内存中去,移入完成后在对这一块内存进行整体回收.由于每次清理对象实际都存在一个整理的过程,所以这种算法不会产生垃圾碎片问题,又因为他是保留有用的对象,直接全部回收一块内存空间,速度自然也比标记-清除算法快很多.

缺点：内存区域分为两块，可使用内存变小

### 垃圾回收算法 - 标记-整理算法

标记过程都相同,整理首先是将存活对象向前移动,将所有存活对象移到前面去,那么此时会产生一个内存分界点,分界点一端全部都是有用对象,另一端全部都是垃圾对象,这时候只需要对分界点的一端进行整体清理就可以了.这个算法同样不会产生垃圾碎片,效率也不低.

### 垃圾回收算法 - 分代收集算法

分代收集算法并不是像前三种算法那样做一个清除的步骤,他只不过是将堆内存分为了年轻代老年代,这样我们就可以通过不同的策略针对不同的区采取不同的垃圾收集算法.
 
### 


















