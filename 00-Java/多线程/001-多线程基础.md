### 一、学习多线程的学习方法

无它，唯看得多做的多。等积累到一定的程度，你就会融会贯通，彻底打通任督二脉。

从大二（2016）开始就学习java的多线程，一直都是很模糊，不明白其中的运行机制。

直到现在，我才懂得了多线程的一些运行机制。

### 二、一个关键的认知

实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以理解为任务是通过线程驱动从而执行的。

### 三、new Thread()里面放一个实现Runnable接口的对象或者一个继承Thread的对象是什么意义？

将实现Runnable接口的类看做是任务类，重写的run方法就是任务。

任务如果是需要放在多线程中执行，那就需要Thread类。

创建一个Thread类，将任务类对象作为参数传递给Thread的构造方法，调用Thread类的start方法就会启动一个线程，它会导致任务类的run方法执行，当run方法执行完毕，线程终止。

### 四、Runnable比Thread具有的优势

适合多个相同的程序代码的线程去处理同一个资源。

可以避免java中的单继承的限制。

增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。

线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类。

### 五、线程sleep之后怎么唤醒？

比如sleep(1000)，等到线程睡眠1s之后，就又处在一个可执行的状态，只需要cpu分配即可执行。

### 六、为什么一个线程多次start()会出现异常

因为线程的生命周期是个不可循环的过程。一个线程对象结束了就不能够再次start()。

### 七、线程规划器的底层原理是什么？



### 八、Thread t1=new Thread(a)，其实发生了什么？为什么t1能够调用到类A的run方法？

类A的方法
```java
Class A implements Runnable {
   ...
}

A  a =new A();
Thread t=new Thread (a);
t.start();
```

在java的Thread源代码中的run方法源码
```java
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```
然而在start方法中没有调用run方法。空空如也。这是因为run方法由java虚拟机来调用，而调用的时间是不确定的
```java
/**
* This method is not invoked for the main method thread or "system"
* group threads created/set up by the VM. Any new functionality added
* to this method in the future may have to also be added to the VM.
*
* A zero status value corresponds to state "NEW".
*/
public synchronized void start()
```
